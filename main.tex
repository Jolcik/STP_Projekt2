\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{polski}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mathtools}

\title{STP projekt nr 2}
\author{Piotr Kostrzeński}
\date{nr indeksu 300421}

\begin{document}

\maketitle

\section*{Wstęp}
Zadany obiekt regulacji jest opisany transmitancją:
\[
    G(s) = \frac{
        K_0 e^{-T_0s}
    }{
        (T_1s+1)(T_2s+1)
    }
\]
gdzie $K_0 = 3,4, T_0 = 5, T_1 = 1,75, T_2 = 5,51$/

\section*{Zadanie 1}
W ramach tego zadania wyznaczę transmitancję dyskretną $G(z)$ na podstawie zadanej transmitancji ciągłej $G(s)$. Zastosuję przy tym ekstrapolator zerowego rzędu oraz okres próbkowania $T_p = 0,5s$. Zadaną transmitancję ciągłą można także przedstawić jako:
\[
    G(s) = e^{-T_0s} \cdot G_0(s)
\]
gdzie:
\[
    G_0(s) = \frac{K_0}{(T_1s+1)(T_2s+1)}
\]
Transmitancję $G_0(s)$ rozkładam na ułamki proste:
\begin{align*}
    G_0(s) & = \frac{K_0}{(T_1s+1)(T_2s+1)} = \frac{\frac{K_0}{T_1T_2}}{(s+\frac{1}{T_1})(s+\frac{1}{T_2})} =  \frac{A}{s+\frac{1}{T_1}} + \frac{B}{s+\frac{1}{T_2}} = \\
    & = \frac{A(s+\frac{1}{T_2}) + B(s+\frac{1}{T_1})}{(s+\frac{1}{T_1})(s+\frac{1}{T_2})} = \frac{(A+B)s + \frac{A}{T_2} + \frac{B}{T_1}}{(s+\frac{1}{T_1})(s+\frac{1}{T_2})}
\end{align*}

\noindent
Przyrównując współczynniki wielomianu w liczniku ułamka otrzymuję układ równań:
\[
    \begin{cases}
        A + B = 0 \\
        \frac{A}{T_2} + \frac{B}{T_1} = \frac{K_0}{T_1T_2}
    \end{cases}
\]
\[
    \begin{cases}
        A + B = 0 \\
        \frac{AT_1 + BT_2}{T_1T_2} = \frac{K_0}{T_1T_2}
    \end{cases}
\]
\[
    \begin{cases}
        A + B = 0 \implies B = - A \\
        AT_1 + BT_2 = K_0
    \end{cases}
\]
\[ AT_1 - AT_2 = K_0\]
\[ (T_1 - T_2)A = K_0\]
\[ A = \frac{K_0}{T_1 - T_2} \]
\[ B = -A = -\frac{K_0}{T_1 - T_2}\]
Podsumowując współczynniki:
\[
    \begin{cases}
         A = \frac{K_0}{T_1 - T_2} \\
         B = -\frac{K_0}{T_1 - T_2}
    \end{cases}
\]
co mi daje:
\[
    G_0(s) = \frac{\frac{K_0}{T_1 - T_2}}{s+\frac{1}{T_1}} + \frac{-\frac{K_0}{T_1 - T_2}}{s+\frac{1}{T_2}}
\]
Transmitancję ciągłą zamieniam na dyskretną według wzoru:
\[
    G_0(z) = \frac{z-1}{z} \cdot Z \left( \frac{G_0(s)}{s} \right)
\]
Daje to:

\begin{align*}
    G_0(z) & = \frac{z-1}{z} \cdot Z \left( \frac{\frac{K_0}{T_1 - T_2}}{s(s+\frac{1}{T_1})} + \frac{-\frac{K_0}{T_1 - T_2}}{s(s+\frac{1}{T_2})} \right) = \\
    & = \frac{z-1}{z} \cdot Z \left( \frac{T_1K_0}{T_1 - T_2}\frac{\frac{1}{T_1}}{s(s+\frac{1}{T_1})} - \frac{T_2K_0}{T_1 - T_2}\frac{\frac{1}{T_2}}{s(s+\frac{1}{T_2})} \right) = \\
    & = \frac{z-1}{z} \left[ 
        \frac{T_1K_0}{T_1 - T_2}\frac{z(1-e^{-\frac{1}{2T_1}})}{(z-1)(z-e^{-\frac{1}{2T_1}})} -
        \frac{T_2K_0}{T_1 - T_2}\frac{z(1-e^{-\frac{1}{2T_2}})}{(z-1)(z-e^{-\frac{1}{2T_2}})}
    \right] \\
    & = \frac{T_1K_0}{T_1 - T_2} \cdot \frac{1-e^{-\frac{1}{2T_1}}}{(z-e^{-\frac{1}{2T_1}})} - \frac{T_2K_0}{T_1 - T_2} \cdot \frac{1-e^{-\frac{1}{2T_2}}}{(z-e^{-\frac{1}{2T_2}})} \\
    & = \frac{K_0}{T_1 - T_2} \left( \frac{T_1(1-e^{-\frac{1}{2T_1}})}{(z-e^{-\frac{1}{2T_1}})} - \frac{T_2(1-e^{-\frac{1}{2T_2}})}{(z-e^{-\frac{1}{2T_2}})} \right) \\ 
    & = \frac{K_0}{T_1 - T_2} \cdot
    \frac{
        T_1(1-e^{-\frac{1}{2T_1}})(z-e^{-\frac{1}{2T_2}}) -
        T_2(1-e^{-\frac{1}{2T_2}})(z-e^{-\frac{1}{2T_1}})
    }{
        (z-e^{-\frac{1}{2T_1}})(z-e^{-\frac{1}{2T_2}})
    } \\
    & = \frac{K_0}{T_1 - T_2} \cdot
    \frac{
        \left[T_1(1-e^{-\frac{1}{2T_1}})-T_2(1-e^{-\frac{1}{2T_2}})\right]z -
        e^{-\frac{1}{2T_1}}T_2(1-e^{-\frac{1}{2T_2}}) - e^{-\frac{1}{2T_2}}T_1(1-e^{-\frac{1}{2T_1}})
    }{
        (z-e^{-\frac{1}{2T_1}})(z-e^{-\frac{1}{2T_2}})
    } 
\end{align*}
\noindent
Ostatecznie:
\begin{align*}
    G_0(z) = \frac{K_0}{T_1 - T_2} \cdot
    \frac{
        \left[T_1(1-e^{-\frac{1}{2T_1}})-T_2(1-e^{-\frac{1}{2T_2}})\right]z -
        e^{-\frac{1}{2T_1}}T_2(1-e^{-\frac{1}{2T_2}}) - e^{-\frac{1}{2T_2}}T_1(1-e^{-\frac{1}{2T_1}})
    }{
        z^2 - (e^{-\frac{1}{2T_1}} + e^{-\frac{1}{2T_2}})z + e^{-\frac{1}{2T_1}}e^{-\frac{1}{2T_2}}
    }
\end{align*}

\noindent
Po podstawieniu liczb otrzymuję taką transmitancję dyskretną:
\begin{align*}
    G_0(z) & = -0,90425 \cdot \frac{
       (0,43491 - 0,47798)z + 0,35919 - 0,39719 
    }{
       z^2 - 1,66473z + 0,68628
    } \\
    & = -0,90425 \cdot \frac{
       -0,04307z - 0,038
    }{
       z^2 - 1,66473z + 0,68628
    } \\ 
    & = \frac{
       0,03894z + 0,0343 
    }{
       z^2 - 1,66473z + 0,68628
    }
\end{align*}
Otrzymaną transmitancję sprawdziłem także w środowisku MATLAB. Najpierw przekształciłem transmitancję ciągłą:
\begin{align*}
    G_0(s) & = \frac{\frac{K_0}{T_1T_2}}{(s+\frac{1}{T_1})(s+\frac{1}{T_2})} \\
    & = \frac{\frac{K_0}{T_1T_2}}{s^2+(\frac{1}{T_1} + \frac{1}{T_2})s + \frac{1}{T_1T_2}}
\end{align*}
Po podstawieniu liczb:
\[
G_0(s) = \frac{0,3526}{s^2+0,7529s + 0,1037}
\]
Transmitancję w takiej postaci można w środowisku MATLAB zamienić na transmitancję dyskretną w poniższy sposób:
\begin{verbatim}
    H = tf([0.3526], [1 0.7529 0.1037]);
    Hd = c2d(H, 0.5);
\end{verbatim}
Wynik powyższych obliczeń wygląda nastepująco:
\begin{verbatim}
    Hd =
 
       0.03895 z + 0.03435
      ----------------------
      z^2 - 1.665 z + 0.6863
\end{verbatim}
\noindent
Co potwierdza poprawność wyżej wykonanych obliczeń. Pozostało jeszcze zająć się pominiętym póki co opóźnieniem. Po przyjęciu okresu próbkowania $T_p = 0,5s$ opóźnieniu ciągłemu $e^{-5s}$ odpowiada opóźnienie dyskretne $z^{-10}$. Stąd ostatecznie, transmitancja dyskretna $G(z)$ przyjmuje postać:
\[
    G(z) = \frac{
       0,03894z + 0,0343 
    }{
       z^2 - 1,66473z + 0,68628
    } z^{-10}
\]

\clearpage \noindent
Obie transmitancje zostały zaimplementowane w środowisku MATLAB. Nastepnie sprawdzono ich odpowiedzi skokowe. Wyglądają one następująco: \\
\includegraphics[width=\textwidth]{STP_projekt2_zad1.png}

\noindent
Jak można zauważyć, transmitancję się praktycznie ze sobą pokrywają (oczywiście biorąc pod uwagę to że jedna jest dyskretna). Dowodzi to poprawności przeprowadzonej dyskretyzacji transmitancji. Współczynnik wzmocnienia statycznego transmitancji można policzyć z poniższych wzorów, dla transmitancji ciągłej i dyskretnej:
\[
    K_{stat} = \lim_{s \to 0} G(s), K_{stat} = \lim_{z \to 1} G(z)
\]
Stąd, dla transmitancji ciągłej:
\[
    K_{stat} = \lim_{s \to 0}  \frac{0,3526}{s^2+0,7529s + 0,1037} e^{-5s} = \frac{0,3526}{0,1037} \approx 3,4
\]
i dla dyskretnej:
\begin{align*}
    K_{stat} & = \lim_{z \to 1} \frac{
       0,03894z + 0,0343 
    }{
       z^2 - 1,66473z + 0,68628
    } z^{-10} \\
    & = \frac{
       0,03894 + 0,0343 
    }{
       1^2 - 1,66473\cdot1 + 0,68628
    } 1^{-10} = \frac{0,07324}{0.02155} \approx 3,3986 \approx 3,4
\end{align*}

\noindent
Obliczone odpowiedzi skokowe są prawie identyczne (błędy związane z zaokrągleniem). Zatem wartości współczynnika wzmocnienia statycznego transmitancji ciągłej i dyskretnej są sobie równe. Można to także zauważyć, na wykresie z odpowiedziami skokowymi. Widać na nim, że odpowiedź skokowa dla obu transmitancji stabilizuje się po pewnym czasie na obliczonych wartościach.

\section*{Zadanie 2}
W tym zadaniu na podstawie transmitancji dyskretnej wyznaczę równanie różnicowe służące do obliczenia wielkości $y(k)$ na podstawie sygnałów wejściowych i wyjściowych z chwil poprzednich o ogólnym wzorze:
\[
    y(k) = \sum_{i=1}^{n}b_i y(k-i) + \sum_{i=1}^{m}c_i u(k-i)
\]
Transmitancja dyskretna przyjmuje poniższą postać:
\[
    G(z) = \frac{Y(z)}{U(z)} = \frac{
       0,03894z + 0,0343 
    }{
       z^2 - 1,66473z + 0,68628
    } z^{-10}
\]
Równanie różnicowe otrzymuję przekształcając powyższe równanie:
\[
    \frac{Y(z)}{U(z)}  = \frac{
       0,03894z + 0,0343 
    }{
       z^2 - 1,66473z + 0,68628
    } z^{-10}
\]
\[
    Y(z)(z^2 - 1,66473z + 0,68628)  = U(z)(0,03894z + 0,0343)z^{-10}
\]
\[
    Y(z)(z^2 - 1,66473z + 0,68628)  = U(z)(0,03894z^{-9} + 0,0343z^{-10})
\]
W dziedzinie czasu dyskretnego mam zatem:
\[
    y(k+2) - 1,66473y(k+1) + 0,68628y(k) = 0,03894u(k-9) + 0,0343u(k-10)
\]
\[
    y(k+2) = 1,66473y(k+1) - 0,68628y(k) + 0,03894u(k-9) + 0,0343u(k-10)
\]
Stosując podstawienie $k := k-2$ otrzymuję:
\[
    y(k) = 1,66473y(k-1) - 0,68628y(k-2) + 0,03894u(k-11) + 0,0343u(k-12)
\]
Jest to ostateczna forma żądanego równania różnicowego. Pozwala ona na obliczenie wielkości $y(k)$ na podstawie sygnałów wejściowych i wyjściowych z chwil poprzednich.


\clearpage
\section*{Zadanie 3}
W tym zadaniu, dla danego obiektu dobiorę ciągły regulator PID metodą Zieglera-Nicholsa. Metoda Zieglera-Nicholsa polega na tym, że zerujemy człon całkujący i różniczkujący regulatora PID, a następnie zwiększamy współczynnik proporcjonalny do momentu otrzymania wzmocnienia krytycznego $K_k$. Wzmocnienie krytyczne oznacza, że układ oscyluje ze stałym okresem oraz amplitudą. Okres tych oscylacji oznaczam jako $T_k$. Wtedy, według metody otrzymujemy podane wartości wwspółczynników:
\begin{align*}
    K_r = 0,6K_k \\
    T_i = 0,5T_k \\
    T_d = 0,12T_k
\end{align*}
Kod symulujący wygląda następująco:
\begin{verbatim}
    sys_ciagly = tf([0.3526], [1 0.7529 0.1037], 'InputDelay', 5);
    regulator = pid(Kr, Ki, Kd);
    sprzezenie_zwrotne = feedback(regulator*sys_ciagly, 1);
\end{verbatim}
Symulację zaczynam od $K_r = 1$: \\
\includegraphics[width=\textwidth]{STP_projekt2_zad3_1.000.png}

\clearpage \noindent
Obiekt jest wtedy niestabilny, trzeba zatem zmniejszyć wzmocnienie. Zmniejszam jego wartość do $K_r = 0,5$:
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.500.png}
\end{center}

\noindent
Teraz układ się stabilizuje na zbyt niskiej wartości (uchyb ustalony) oraz nie ma oscylacji o stałej amplitudzie, zwiększam zatem $K_r$ do $0,75$: 
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.750.png}
\end{center}

\clearpage \noindent
Za duże wzmocnienie więc je zmniejszam do $K_r = 0,625$:
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.625.png}
\end{center}
Tym razem jest ono za małe, więc je zwiększam do $K_r = 0,650$
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.650.png}
\end{center}

\clearpage \noindent
Dalej za małe, zwiększam do $K_r = 0,675$
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.675.png}
\end{center}
Wzmocnienie $K_r = 0,675$ okazuje się poprawnym. Układ oscyluje ze stałą amplitudą wokół jednej wartości. Oznacza, to że jest to wzmocnienie krytyczne. Okres oscylacji wynosi 20 sekund. Stąd, mam parametry:
\begin{align*}
    K_k = 0,675 \\
    T_k = 20
\end{align*}
Na tej podstawie mogę wyliczyć parametry regulatora:
\begin{align*}
    K_r & = 0,6K_k = 0,6 \cdot 0,675 = 0,405 \\
    T_i & = 0,5T_k = 0,5 \cdot 20 = 10 \\
    T_d & = 0,12T_k = 0,12 \cdot 20 = 2,4
\end{align*}
Mogę także wyznaczyć wartości paremetrów dyskretnego regulatora PID definiowanego poprzez wzory:
\begin{align*}
    r_2 & = \frac{KT_d}{T} = \frac{0,405 \cdot 2,4}{0,5} = 1,944 \\
    r_1 & = K \left( \frac{T}{2T_i}-2\frac{T_d}{T}-1 \right) = 0,405 \cdot (0,025 - 9,6 - 1) = -4,2829 \\
    r_0 & = K \left( 1 + \frac{T}{2T_i} + \frac{T_d}{T} \right) = 0,405 \cdot ( 1 + 0,025 + 4,8) = 2,3591
\end{align*}

\clearpage \noindent
Sprawdzam działanie regulatora po zastosowaniu obliczonych parametrów:
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.405.png}
\end{center}
Wyjście obiektu ewidentnie dąży do zadanej wartości. Mimo wszystko, jakość regulacji jest dosyć słaba. Wystarczy jednak obniżyć wartości parametru $T_d$ do $T_d=1,2$, co powoduje otrzymanie o wiele lepszej trajektorii:
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.405_2.png}
\end{center}
Trajektorię można jeszcze poprawić zwiększając czas całkowania do $T_i = 20$:
\begin{center}
    \includegraphics[width=0.93\textwidth]{STP_projekt2_zad3_0.405_3.png}
\end{center}
Dzięki temu osiągnięto dużo mniejsze przeregulowanie przy podobnym czasie regulacji. \\

\noindent
Podsumowując, po dwóch małych poprawkach, za pomocą Metody Zieglera-Nicholsa zostały wyznaczone takie parametry regulatora PID:
\begin{align*}
    K_r & = 0,405 \\
    T_i & = 20 \\
    T_d & = 1,2
\end{align*}
Wtedy też, parametry dyskretnego regulatora będą równe:
\begin{align*}
    r_2 & = \frac{KT_d}{T} = \frac{0,405 \cdot 2,4}{0,5} = 1,944 \\
    r_1 & = K \left( \frac{T}{2T_i}-2\frac{T_d}{T}-1 \right) = 0,405 \cdot (0,0125 - 4,8 - 1) = -2,3439 \\
    r_0 & = K \left( 1 + \frac{T}{2T_i} + \frac{T_d}{T} \right) = 0,405 \cdot ( 1 + 0,0125 + 2,4) = 1,3821
\end{align*}

\clearpage
\section*{Zadanie 4 - regulator PID}
W tej części zadania zaimplementuję w środowisku MATLAB program do symulacji cyfrowego algorytmu PID. \\

\noindent
Zaczynam od zdefiniowania współczynników regulatora PID:
\begin{verbatim}
    T = 0.5;
    Kr = 0.405;
    Ti = 10;
    Td = 2.4;
\end{verbatim}
Oraz według wzorów:
\begin{align*}
    r_2 & = \frac{KT_d}{T} \\
    r_1 & = K \left( \frac{T}{2T_i}-2\frac{T_d}{T}-1 \right) \\
    r_0 & = K \left( 1 + \frac{T}{2T_i} + \frac{T_d}{T} \right) 
\end{align*}
liczę współczynniki dyskretne:
\begin{verbatim}
    r2 = (Kr*Td)/T;
    r1 = Kr*(T/(2*Ti) - 2*(Td/T) - 1);
    r0 = Kr*(1 + T/(2*Ti) + Td/T);
\end{verbatim}
Definiuję też czas trwania symulacji w chwilach dyskretnych $k$:
\begin{verbatim}
    kk = 200;
\end{verbatim}
Następnie na podstawie tej wielkości definiuję wcześniej wektory wejścia, wyjścia oraz uchybu:
\begin{verbatim}
    u = zeros(kk, 1);
    y = zeros(kk, 1);
    e = zeros(kk, 1);
\end{verbatim}
Potem definiuję wartości zadaną wyjścia obiektu. Na początku jest ono równe 0, po to aby w chwili $k=15$ zmienić się skokowo do wartości 1. Chwila $k$ jest równa 15, ponieważ ze względu na równanie różnicowe układ naprawdę zaczyna działać dla $k>12$. Stąd, dla pewności, żeby wszelkie zmienne zdążyły się dobrze zainicjalizować skok ustawiłem w chwili $k=15$:
\begin{verbatim}
    y_zad = zeros(kk, 1);
    y_zad(15:kk) = 1; 
\end{verbatim}

\noindent
Ostatecznie, pozostaje przeprowadzenie samej symulacji. Równanie różnicowe modelu przyjmuje postać:
\[
    y(k) = 1,66473y(k-1) - 0,68628y(k-2) + 0,03894u(k-11) + 0,0343u(k-12)
\]
Ostatni wyraz jest zależny od $u(k-12)$ dlatego pętlę symulacji zaczynam od $k=13$:
\begin{verbatim}
    for k = 13:kk
        ...
    end
\end{verbatim}
Wewnątrz pętli, na początku według podanego równania różnicowego symuluję zachowanie obiektu:
\begin{verbatim}
    y(k) = 1.66473*y(k-1) - 0.68628*y(k-2) 
                                + 0.03894*u(k-11) + 0.0343*u(k-12);
\end{verbatim}
Potem obliczam uchyb regulacji:
\begin{verbatim}
    e(k) = y_zad(k)-y(k);
\end{verbatim}
Na końcu, według równania różnicowego na sterowanie:
\[
    u(k) = r_2e(k-2) + r_1e(k-1) + r_0e(k) + u(k-1)
\]
liczę nową wartość sterowania dla obiektu:
\begin{verbatim}
    u(k) = r2*e(k-2) + r1*e(k-1) + r0*e(k) + u(k-1);
\end{verbatim}
Łącznie, pętla symulacji przedstawia się jak poniżej:
\begin{verbatim}
    for k = 13:kk
        y(k) = 1.66473*y(k-1) - 0.68628*y(k-2) 
                                    + 0.03894*u(k-11) + 0.0343*u(k-12);
        e(k) = y_zad(k) - y(k);
        u(k) = r2*e(k-2) + r1*e(k-1) + r0*e(k) + u(k-1);
    end
\end{verbatim}

\noindent
Na końcu pliku zamieszczony jest także kod generujący wykresy w MATLABie, ale nie służy on symulacji cyfrowego algorytmu PID, dlatego pominę jego treść oraz wyjaśnienie. \\

\noindent
Używając powyższego kodu przeprowadziłem symulację działania regulatora. Zauważyć można na pewno, że model dyskretny ma troszkę inną specyfikę. Dokładniej, po przeprowadzeniu kilku eksperymentów wzmocnienie krytyczne dla regulatora dyskretnego jest równe $K_k = 0,657$ (w przypadku regulatora ciągłego było to $K_k = 0,675$). Opisana wyżej różnica wynika najprawdopodobniej z przyjętych przeze mnie zaokrągleń. Trajektoria w takim przypadku została przedstawiona na kolejnej stronie.

\clearpage
\begin{center}
    \includegraphics[width=0.9\textwidth]{STP_projekt2_zad4_pid_1.png}
\end{center}
Okres oscylacji jest taki sam jak w przypadku ciągłego regulatora. Po wyznaczeniu prametrów według metody Zieglera-Nicholsa (jedyna różnica to $Kr = 0,3402$) trajektoria wygląda jak poniżej:
\begin{center}
    \includegraphics[width=0.9\textwidth]{STP_projekt2_zad4_pid_2.png}
\end{center}
Jak widać, otrzymana jakość regulacji jest akceptowalna, dlatego tak ją zostawiam.


\section*{Zadanie 4 - regulator DMC}
W drugiej części zadania zaimplementuję symulację cyfrowego algorytmu predykcyjnego DMC w wersji analitycznej, bez ograniczeń. \\

\noindent
Jako że w algorytmie  DMC  obiekt jest  modelowany dyskretnymi  odpowiedziami skokowymi, na samym początku należy przeprowadzić symulację odpowiedzi skokowej dyskretnego modelu:
\begin{verbatim}
    sys_dyskretny = tf([0.03894 0.0343], [1 -1.66473 0.68628],
                                        0.5, 'InputDelay', 10);
    s = step(sys_dyskretny, 100);
\end{verbatim}

\noindent
Na tej podstawie otrzymuję wektor $s$. Następnie definiuję wartości parametrów algorytmu:
\begin{verbatim}
    N = 10;
    Nu = 10;
    D = 10;
    lambda = 1;
\end{verbatim}

\noindent
Do realizacji algorytmu DMC potrzebna będzie macierz $M^P$ o wymiarowości $N \times D-1$ i strukturze:
\begin{equation*}
    M^P = \begin{bmatrix}
        s_2 - s_1 & s_3 - s_2 & \dots & s_D - S_{D-1} \\
        s_3 - s_1 & s_4 - s_2 & \dots & s_{D+1} - S_{D-1} \\
        \vdots & \vdots & \ddots & \vdots \\
        s_{N+1} - s_1 & s_{N+2} - s_2 & \dots & s_{N+D+1} - S_{D-1} \\
    \end{bmatrix}
\end{equation*}

\noindent
W MATLABie generuję ją w poniższy sposób:
\begin{verbatim}
    Mp = zeros(N, D-1);
    for i = 1:N
        for j = 1:D-1
            if i + j < D
                Mp(i, j) = s(i + j) - s(j);
            else
                Mp(i, j) = s(D) - s(j);
            end
        end
    end
\end{verbatim}

\noindent
Potrzebna będzie także macierz dynamiczna $M$ o wymiarowości $N \times N_u$ i strukturze:
\begin{equation*}
    M^P = \begin{bmatrix}
        s_1 & 0 & \dots & 0 \\
        s_2 & s_1 & \dots & 0 \\
        \vdots & \vdots & \ddots & \vdots \\
        s_N & s_{N-1} & \dots & s_{N+-N_u+1} \\
    \end{bmatrix}
\end{equation*}

\clearpage \noindent
Jej implementacja w środowisku MATLAB przedstawia się poniższo:
\begin{verbatim}
    M = zeros(N, Nu);
    for i = 1:N
        for j = 1:i
            if j <= Nu
                M(i, j) = s(i - j + 1);
            end
        end
    end
\end{verbatim}

\noindent
Idąc dalej, do realizacji algorytmu będzie macierz $K$:
\[
    K = (M^T \Psi M + \Lambda)^{-1} M^T \Psi
\]
gdzie $\Lambda$ to macierz jednostkowa pomnożona przez parametr $\lambda$. Obliczenie macierzy w MATLABie:
\begin{verbatim}
    I = eye(Nu);
    K = (((M')*M + lambda*I)^(-1))*(M');
\end{verbatim}

\noindent
Do obliczenia sterowania według prawa regulacji:
\[
    \Delta u(k) = k^e (y^{zad}(k) - y(k)) - \sum_{j=1}^{D-1}k_j^u \Delta u(k-j)
\]
gdzie
\[
    k_j^u = \overline{K}_1 M_j^P
\]
\[
    k^e = \sum_{p=1}^N k_{1, p}
\]
\noindent
potrzebne będą wektory $k^e$ oraz $k^u$. Obliczam je jak poniżej:
\begin{verbatim}
    ku = K(1, :)*Mp;
    ke = sum(K(1, :));
\end{verbatim}

\noindent
Dalsza część kodu jest podobna do regulatora PID, na początku inicjalizuję zmienne:

\begin{verbatim}
    kk = 120;
    u = zeros(kk, 1);
    d_upk = zeros(1, D-1);
    y = zeros(kk, 1);
    y_zad = zeros(kk, 1);
    y_zad(15:kk) = 1; 
    e = zeros(kk, 1);
\end{verbatim}

\clearpage \noindent
Następnie piszę główną pętlę symulacji (oprócz obliczania sygnału sterującego):
\begin{verbatim}
    for k = 13:kk
        y(k) = 1.66473*y(k-1) - 0.68628*y(k-2) 
                                    + 0.03894*u(k-11) + 0.0343*u(k-12);
        e(k) = y_zad(k)-y(k);
        
        ...
    end
\end{verbatim}

\noindent
W przypadku regulatora DMC obliczanie wartości sygnału sterującego $u$ wygląda tak jak na przytoczonym wcześniej prawie regulacji. Na początku przesuwam wszystkie poprzednie przyrosty sterowania $\Delta u$ w wektorze przechowującym te wartości:
\begin{verbatim}
    d_upk(2:D-1) = d_upk(1:D-2);
\end{verbatim}

\noindent
Następnie obliczam przyrost sygnału sterującego $\Delta u$ oraz zapisują go do wektora zapisującego te przerosty:
\begin{verbatim}
    d_uk = ke*e(k) - ku*d_upk';
    d_upk(1) = d_uk;
\end{verbatim}

\noindent
Na końcu obliczam nową wartość sygnału sterującgo $u$:
\begin{verbatim}
    u(k) = u(k-1) + d_uk;
\end{verbatim}

\noindent
Podsumowując, petla symulacji przedstawia się jak poniżej:
\begin{verbatim}
    for k = 13:kk
        y(k) = 1.66473*y(k-1) - 0.68628*y(k-2) 
                                    + 0.03894*u(k-11) + 0.0343*u(k-12);
        e(k) = y_zad(k)-y(k);
        
        d_upk(2:D-1) = d_upk(1:D-2);
        d_uk = ke*e(k) - ku*d_upk';
        d_upk(1) = d_uk;
        u(k) = u(k-1) + d_uk;
    end
\end{verbatim}

\noindent
Reszta kodu w pliku zajmuje się wygenerowaniem oraz zapisaniem wykresu obrazującym działanie regulatora. Nie ma to związku z samym algorytmem dlatego pomijam ten fragment. \\

\noindent
W ten sposób napisałem program pozwalający zasymulować działanie algorytmu DMC w wersji analitycznej, bez ograniczeń. W następnym zadaniu użyję go przy poszukiwaniu odpowiednich parametrów regulatora.



\end{document}

